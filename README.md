# Yoienko-Tatiana.-Control-Work
## Задание
Написать программу, которая из имеющегося массива строк, формирует массив из строк, длинна которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.
## Подготовка
На этапе создания блок-схемы, было принято решение написать метод (*TransferArrElem*), который будет выполнять поставленную задачу.

Необходимо инициализировать метод типа *void* и в качестве аргумента передать массив строк *"arrOfStr"*.
## Основная часть
### **Этап первый**
На первом этапе решения необходимо определить количество элементов, которые будут входить в конечный массив строк.

На этом этапе нерационально создавать конечный массив, так как все зависит от его размера. Если элементов, перенесенных в него будет меньше, чем его размер, тогда останутся пустые элементы. В таком случае зря будет выделена память. А если элементов будет больще, чем размер массива, тогда алгоритм не будет выполнять поставленную задачу. Таким образом:
1. Вводим две переменные. *"strSize = 3"* - переменная, с помощью которой будут определяться подходящие элементы; *"sizeNewArr = 0"* - переменная, в которую будет записано количество подходящих элементов, и в дальнейшем эта переменная станет размером конечного массива.
2. Открываем цикл *for* с условиями *"i = 0; i < arrOfStr.Length; i++"*.
3. В цикле *for* вводим оператор *if* с условием *"arrOfStr[i].Length<=strSize"*, перебирая каждый элемент и проверяя его длинну. Если условие выполняется, тогда к переменной *sizeNewArr* добавляется 1, если не выполняется, тогда возвращаемся к началу цикла.
### **Этап второй**
После того, как определен размер массива, необходимо проверить не равен ли он нулю.
* Вводится оператор *if/else* с условием *"sizeNewArr > 0"*. Если условие выполняется, то переходим к следующему этапу, а именно создание конечного массива и переноса в него подходящих элементов. Если не выполняется, тогда переходим к *else* и выводим результат о том, что массив пустой.

В первом варианте алгоритма такой проверки не было. Без нее алгоритм так же выполняет поставленную задачу, однако, даже если ни один элемент не соответсвовал условию и переменная *sizeNewArr* осталась с нулевым значением, создавался бы новый массив, перебирался бы каждый элемент и показывал результат с пустым массивом. Такой алгоритм был бы менее оптимальным.
### **Этап третий**
На третьем этапе происходят основные операции по выполнению поставленной задачи. Итак, если на втором этапе условие оператора *if* было true, переходим в тело оператора *if*. Далее:
1. Вводим новый массив строк *newArrOfStr* размером *sizeNewArr*, а также переменную *index = 0* - переменная, которая будет увеличивать идекс массива *newArrOfStr*, в зависимости от удовлетворения условия.
2. Открываем цикл *for* с условие *i = 0; i < arrOfStr.Length; i++*.
3. В теле цикла *for* вводим оперот *if* с условием *arrOfStr[i].Length <= strSize*. Если true, тогда элемент исходного массива записываем в конечный массив, то есть *newArrOfStr[index] = arrOfStr[i]*, и увеличиваем переменную *index* на единицу - *index++*. Если false, тогда возвращаемся к началу цикла *for*.
4. После того как все элементы исходного массива пройдены и нужные перенесены в конечный массив выводим результат и закрываем тело метода.
## Заключение
После того, как написан метод *TransferArrElem*, задаем массив строк, который необходимо передать в данный метод.

Объявляем метод и передаем нужный массив.