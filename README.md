# Yoienko-Tatiana.-Control-Work
## Задание
Написать программу, которая из имеющегося массива строк, формирует массив из строк, длинна которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.
## Подготовка
На этапе создания блок-схемы, было принято решение написать метод (*TransferArrElem*), который будет выполнять поставленную задачу.

Необходимо инициализировать метод типа *void* и в качестве аргумента передать массив строк *"arrOfStr"*.
## Основная часть
### **Этап первый**
На первом этапе решения необходимо определить количество элементов, которые будут входить в конечный массив строк.

На этом этапе нерационально создавать конечный массив, так как все зависит от его размера. Если элементов, перенесенных в него будет меньше, чем его размер, тогда останутся пустые элементы. В таком случае зря будет выделена память. А если элементов будет больще, чем размер массива, тогда алгоритм не будет выполнять поставленную задачу. Таким образом:
1. Вводим две переменные. *"strSize = 3"* - переменная, с помощью которой будут определяться подходящие элементы; *"sizeNewArr = 0"* - переменная, в которую будет записано количество подходящих элементов, и в дальнейшем эта переменная станет размером конечного массива.
2. Открываем цикл *for* с условиями *"i = 0; i < arrOfStr.Length; i++"*.
3. В цикле *for* вводим оператор *if* с условием *"arrOfStr[i].Length<=strSize"*, перебирая каждый элемент и проверяя его длинну. Если условие выполняется, тогда к переменной *sizeNewArr* добавляется 1, если не выполняется, тогда возвращаемся к началу цикла.
### **Этап второй**
После того, как определен размер массива, необходимо проверить не равен ли он нулю.
* Вводится оператор *if/else* с условием *"sizeNewArr > 0"*. Если условие выполняется, то переходим к следующему этапу, а именно создание конечного массива и переноса в него подходящих элементов. Если не выполняется, тогда переходим к *else* и выводим результат о том, что массив пустой.

В первом варианте алгоритма такой проверки не было. Без нее алгоритм так же выполняет поставленную задачу, однако, даже если ни один элемент не соответсвовал условию и переменная *sizeNewArr* осталась с нулевым значением, создавался бы новый массив, перебирался бы каждый элемент и показывал результат с пустым массивом. Такой алгоритм был бы менее оптимальным.
### **Этап третий**